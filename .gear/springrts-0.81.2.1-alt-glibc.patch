diff --git a/rts/Lua/LuaHandle.cpp b/rts/Lua/LuaHandle.cpp
index 3e695f7..8f6539b 100644
--- a/rts/Lua/LuaHandle.cpp
+++ b/rts/Lua/LuaHandle.cpp
@@ -148,7 +148,7 @@ bool CLuaHandle::LoadCode(const string& code, const string& debug)
 
 #if defined(__SUPPORT_SNAN__) && !defined(USE_GML)
 	// do not signal floating point exceptions in user Lua code
-	feclearexcept(streflop::FPU_Exceptions(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW));
+	sfeclearexcept(streflop::FPU_Exceptions(sFE_INVALID | sFE_DIVBYZERO | sFE_OVERFLOW));
 #endif
 
 	int error;
@@ -158,7 +158,7 @@ bool CLuaHandle::LoadCode(const string& code, const string& debug)
 		                error, debug.c_str(), lua_tostring(L, -1));
 		lua_pop(L, 1);
 #if defined(__SUPPORT_SNAN__) && !defined(USE_GML)
-		feraiseexcept(streflop::FPU_Exceptions(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW));
+		feraiseexcept(streflop::FPU_Exceptions(sFE_INVALID | sFE_DIVBYZERO | sFE_OVERFLOW));
 #endif
 		return false;
 	}
@@ -169,7 +169,7 @@ bool CLuaHandle::LoadCode(const string& code, const string& debug)
 	SetActiveHandle(orig);
 
 #if defined(__SUPPORT_SNAN__) && !defined(USE_GML)
-	feraiseexcept(streflop::FPU_Exceptions(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW));
+	feraiseexcept(streflop::FPU_Exceptions(sFE_INVALID | sFE_DIVBYZERO | sFE_OVERFLOW));
 #endif
 
 	if (error != 0) {
@@ -213,7 +213,7 @@ int CLuaHandle::RunCallInTraceback(int inArgs, int outArgs, int errfuncIndex, st
 {
 #if defined(__SUPPORT_SNAN__) && !defined(USE_GML)
 	// do not signal floating point exceptions in user Lua code
-	feclearexcept(streflop::FPU_Exceptions(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW));
+	sfeclearexcept(streflop::FPU_Exceptions(sFE_INVALID | sFE_DIVBYZERO | sFE_OVERFLOW));
 #endif
 
 	CLuaHandle* orig = activeHandle;
@@ -241,7 +241,7 @@ int CLuaHandle::RunCallInTraceback(int inArgs, int outArgs, int errfuncIndex, st
 	}
 
 #if defined(__SUPPORT_SNAN__) && !defined(USE_GML)
-	feraiseexcept(streflop::FPU_Exceptions(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW));
+	feraiseexcept(streflop::FPU_Exceptions(sFE_INVALID | sFE_DIVBYZERO | sFE_OVERFLOW));
 #endif
 	return error;
 }
diff --git a/rts/System/FPUCheck.h b/rts/System/FPUCheck.h
index 2c383c8..b99d47e 100644
--- a/rts/System/FPUCheck.h
+++ b/rts/System/FPUCheck.h
@@ -70,7 +70,7 @@ static inline void good_fpu_control_registers(const char* text)
 	// We are paranoid.
 	// We don't trust the enumeration constants from streflop / (g)libc.
 #if defined(STREFLOP_SSE)
-	fenv_t fenv;
+	sfenv_t fenv;
 	fegetenv(&fenv);
 
 	#if defined(__SUPPORT_SNAN__) && !defined(USE_GML)	// -fsignaling-nans
@@ -87,11 +87,11 @@ static inline void good_fpu_control_registers(const char* text)
 		// Set single precision floating point math.
 		streflop_init<streflop::Simple>();
 	#if defined(__SUPPORT_SNAN__) && !defined(USE_GML)
-		feraiseexcept(streflop::FPU_Exceptions(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW));
+		feraiseexcept(streflop::FPU_Exceptions(sFE_INVALID | sFE_DIVBYZERO | sFE_OVERFLOW));
 	#endif
 	}
 #elif defined(STREFLOP_X87)
-	fenv_t fenv;
+	sfenv_t fenv;
 	fegetenv(&fenv);
 	#if defined(__SUPPORT_SNAN__) && !defined(USE_GML)
 	bool ret = (fenv & 0x1F3F) == 0x0072 || (fenv & 0x1F3F) == 0x003F;
@@ -103,7 +103,7 @@ static inline void good_fpu_control_registers(const char* text)
 		// Set single precision floating point math.
 		streflop_init<streflop::Simple>();
 	#if defined(__SUPPORT_SNAN__) && !defined(USE_GML)
-		feraiseexcept(streflop::FPU_Exceptions(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW));
+		feraiseexcept(streflop::FPU_Exceptions(sFE_INVALID | sFE_DIVBYZERO | sFE_OVERFLOW));
 	#endif
 	}
 #endif
diff --git a/rts/lib/streflop/FPUSettings.h b/rts/lib/streflop/FPUSettings.h
index 013be87..060a940 100644
--- a/rts/lib/streflop/FPUSettings.h
+++ b/rts/lib/streflop/FPUSettings.h
@@ -56,30 +56,30 @@ namespace streflop {
 // Give warning in case these flags would be defined already, this is indication
 // of potential confusion!
 
-#if defined(FE_INVALID) || defined(FE_DENORMAL) || defined(FE_DIVBYZERO) || defined(FE_OVERFLOW) || defined(FE_UNDERFLOW) || defined(FE_INEXACT) || defined(FE_DOWNWARD) || defined(FE_TONEAREST) || defined(FE_TOWARDZERO) || defined(FE_UPWARD)
+#if defined(sFE_INVALID) || defined(FE_DENORMAL) || defined(sFE_DIVBYZERO) || defined(sFE_OVERFLOW) || defined(sFE_UNDERFLOW) || defined(sFE_INEXACT) || defined(FE_DOWNWARD) || defined(FE_TONEAREST) || defined(FE_TOWARDZERO) || defined(FE_UPWARD)
 
 #warning STREFLOP: FE_XXX flags were already defined and will be redefined! Check you do not use the system libm.
-#undef FE_INVALID
+#undef sFE_INVALID
 #undef FE_DENORMAL
-#undef FE_DIVBYZERO
-#undef FE_OVERFLOW
-#undef FE_UNDERFLOW
-#undef FE_INEXACT
-#undef FE_INEXACT
+#undef sFE_DIVBYZERO
+#undef sFE_OVERFLOW
+#undef sFE_UNDERFLOW
+#undef sFE_INEXACT
+#undef sFE_INEXACT
 #undef FE_ALL_EXCEPT
 #undef FE_DOWNWARD
 #undef FE_TONEAREST
 #undef FE_TOWARDZERO
 #undef FE_UPWARD
-#endif // defined(FE_INVALID) || ...
+#endif // defined(sFE_INVALID) || ...
 
 
 // Flags for FPU exceptions
 enum FPU_Exceptions {
 
     // Invalid operation. If not signaling, gives NaN instead
-    FE_INVALID = 0x0001,
-    #define FE_INVALID FE_INVALID
+    sFE_INVALID = 0x0001,
+    #define sFE_INVALID sFE_INVALID
 
     // Extension: for x86 and SSE
     // Denormal operand. If not signaling, use denormal arithmetic as usual
@@ -87,20 +87,20 @@ enum FPU_Exceptions {
     #define FE_DENORMAL FE_DENORMAL
 
     // Division by zero. If not signaling, uses +/- infinity
-    FE_DIVBYZERO = 0x0004,
-    #define FE_DIVBYZERO FE_DIVBYZERO
+    sFE_DIVBYZERO = 0x0004,
+    #define sFE_DIVBYZERO sFE_DIVBYZERO
 
     // Overflow. If not signaling, round to nearest (including infinity) according to rounding mode
-    FE_OVERFLOW = 0x0008,
-    #define FE_OVERFLOW FE_OVERFLOW
+    sFE_OVERFLOW = 0x0008,
+    #define sFE_OVERFLOW sFE_OVERFLOW
 
     // Underflow. If not signaling, use 0 instead
-    FE_UNDERFLOW = 0x0010,
-    #define FE_UNDERFLOW FE_UNDERFLOW
+    sFE_UNDERFLOW = 0x0010,
+    #define sFE_UNDERFLOW sFE_UNDERFLOW
 
     // Rounding was not exact (ex: sqrt(2) is never exact) or when overflow causes rounding
-    FE_INEXACT = 0x0020,
-    #define FE_INEXACT FE_INEXACT
+    sFE_INEXACT = 0x0020,
+    #define sFE_INEXACT sFE_INEXACT
 
     // Combination of all the above
     FE_ALL_EXCEPT  = 0x003F
@@ -157,7 +157,7 @@ inline int feraiseexcept(FPU_Exceptions excepts) {
 }
 
 /// Clear exceptions for these flags
-inline int feclearexcept(int excepts) {
+inline int sfeclearexcept(int excepts) {
     unsigned short fpu_mode;
     STREFLOP_FSTCW(fpu_mode);
     fpu_mode |= excepts;
@@ -182,33 +182,33 @@ inline int fesetround(FPU_RoundMode roundMode) {
     return 0;
 }
 
-typedef short int fenv_t;
+typedef short int sfenv_t;
 
 /// Default env. Defined in Math.cpp to be 0, and initalized on first use to the permanent holder
-extern fenv_t FE_DFL_ENV;
+extern sfenv_t sFE_DFL_ENV;
 
 /// Get FP env into the given structure
-inline int fegetenv(fenv_t *envp) {
+inline int fegetenv(sfenv_t *envp) {
     // check that default env exists, otherwise save it now
-    if (!FE_DFL_ENV) STREFLOP_FSTCW(FE_DFL_ENV);
+    if (!sFE_DFL_ENV) STREFLOP_FSTCW(sFE_DFL_ENV);
     // Now store env into argument
     STREFLOP_FSTCW(*envp);
     return 0;
 }
 
 /// Sets FP env from the given structure
-inline int fesetenv(const fenv_t *envp) {
+inline int fesetenv(const sfenv_t *envp) {
     // check that default env exists, otherwise save it now
-    if (!FE_DFL_ENV) STREFLOP_FSTCW(FE_DFL_ENV);
+    if (!sFE_DFL_ENV) STREFLOP_FSTCW(sFE_DFL_ENV);
     // Now overwrite current env by argument
     STREFLOP_FLDCW(*envp);
     return 0;
 }
 
 /// get env and clear exceptions
-inline int feholdexcept(fenv_t *envp) {
+inline int feholdexcept(sfenv_t *envp) {
     fegetenv(envp);
-    feclearexcept(FE_ALL_EXCEPT);
+    sfeclearexcept(FE_ALL_EXCEPT);
     return 0;
 }
 
@@ -231,7 +231,7 @@ template<> inline void streflop_init<Simple>() {
 
     // Enable signaling nans if compiled with this option.
 #if defined(__SUPPORT_SNAN__) && !defined(USE_GML)
-    feraiseexcept(streflop::FPU_Exceptions(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW));
+    feraiseexcept(streflop::FPU_Exceptions(sFE_INVALID | sFE_DIVBYZERO | sFE_OVERFLOW));
 #endif
 }
 
@@ -243,7 +243,7 @@ template<> inline void streflop_init<Double>() {
     STREFLOP_FLDCW(fpu_mode);
 
 #if defined(__SUPPORT_SNAN__) && !defined(USE_GML)
-    feraiseexcept(streflop::FPU_Exceptions(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW));
+    feraiseexcept(streflop::FPU_Exceptions(sFE_INVALID | sFE_DIVBYZERO | sFE_OVERFLOW));
 #endif
 }
 
@@ -256,7 +256,7 @@ template<> inline void streflop_init<Extended>() {
     STREFLOP_FLDCW(fpu_mode);
 
 #if defined(__SUPPORT_SNAN__) && !defined(USE_GML)
-    feraiseexcept(streflop::FPU_Exceptions(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW));
+    feraiseexcept(streflop::FPU_Exceptions(sFE_INVALID | sFE_DIVBYZERO | sFE_OVERFLOW));
 #endif
 }
 #endif // defined(Extended)
@@ -280,7 +280,7 @@ inline int feraiseexcept(FPU_Exceptions excepts) {
 }
 
 /// Clear exceptions for these flags
-inline int feclearexcept(int excepts) {
+inline int sfeclearexcept(int excepts) {
     // Just in case the compiler would store a value on the st(x) registers
     unsigned short x87_mode;
     STREFLOP_FSTCW(x87_mode);
@@ -313,46 +313,46 @@ inline int fesetround(FPU_RoundMode roundMode) {
 }
 
 /// stores both x87 and SSE words
-struct fenv_t {
+struct sfenv_t {
     int sse_mode;
     short int x87_mode;
 };
 
 /// Default env. Defined in Math.cpp, structs are initialized to 0
-extern fenv_t FE_DFL_ENV;
+extern sfenv_t sFE_DFL_ENV;
 
 /// Get FP env into the given structure
-inline int fegetenv(fenv_t *envp) {
+inline int fegetenv(sfenv_t *envp) {
     // check that default env exists, otherwise save it now
-    if (!FE_DFL_ENV.x87_mode) STREFLOP_FSTCW(FE_DFL_ENV.x87_mode);
+    if (!sFE_DFL_ENV.x87_mode) STREFLOP_FSTCW(sFE_DFL_ENV.x87_mode);
     // Now store env into argument
     STREFLOP_FSTCW(envp->x87_mode);
 
     // For SSE
-    if (!FE_DFL_ENV.sse_mode) STREFLOP_STMXCSR(FE_DFL_ENV.sse_mode);
+    if (!sFE_DFL_ENV.sse_mode) STREFLOP_STMXCSR(sFE_DFL_ENV.sse_mode);
     // Now store env into argument
     STREFLOP_STMXCSR(envp->sse_mode);
     return 0;
 }
 
 /// Sets FP env from the given structure
-inline int fesetenv(const fenv_t *envp) {
+inline int fesetenv(const sfenv_t *envp) {
     // check that default env exists, otherwise save it now
-    if (!FE_DFL_ENV.x87_mode) STREFLOP_FSTCW(FE_DFL_ENV.x87_mode);
+    if (!sFE_DFL_ENV.x87_mode) STREFLOP_FSTCW(sFE_DFL_ENV.x87_mode);
     // Now overwrite current env by argument
     STREFLOP_FLDCW(envp->x87_mode);
 
     // For SSE
-    if (!FE_DFL_ENV.sse_mode) STREFLOP_STMXCSR(FE_DFL_ENV.sse_mode);
+    if (!sFE_DFL_ENV.sse_mode) STREFLOP_STMXCSR(sFE_DFL_ENV.sse_mode);
     // Now overwrite current env by argument
     STREFLOP_LDMXCSR(envp->sse_mode);
     return 0;
 }
 
 /// get env and clear exceptions
-inline int feholdexcept(fenv_t *envp) {
+inline int feholdexcept(sfenv_t *envp) {
     fegetenv(envp);
-    feclearexcept(FE_ALL_EXCEPT);
+    sfeclearexcept(FE_ALL_EXCEPT);
     return 0;
 }
 
@@ -429,7 +429,7 @@ inline int feraiseexcept(FPU_Exceptions excepts) {
 }
 
 /// Clear exceptions for these flags
-inline int feclearexcept(int excepts) {
+inline int sfeclearexcept(int excepts) {
     // Use positive logic
     SoftFloat::float_exception_realtraps &= ~( excepts );
     return 0;
@@ -462,23 +462,23 @@ inline int fesetround(FPU_RoundMode roundMode) {
 }
 
 /// SoftFloat environment comprises non-volatile state variables
-struct fenv_t {
+struct sfenv_t {
     char tininess;
     char rounding_mode;
     int exception_realtraps;
 };
 
 /// Default env. Defined in Math.cpp, initialized to some invalid value for detection
-extern fenv_t FE_DFL_ENV;
+extern sfenv_t sFE_DFL_ENV;
 
 /// Get FP env into the given structure
-inline int fegetenv(fenv_t *envp) {
+inline int fegetenv(sfenv_t *envp) {
     // check that default env exists, otherwise save it now
-    if (FE_DFL_ENV.tininess==42) {
+    if (sFE_DFL_ENV.tininess==42) {
         // First use: save default environment now
-        FE_DFL_ENV.tininess = SoftFloat::float_detect_tininess;
-        FE_DFL_ENV.rounding_mode = SoftFloat::float_rounding_mode;
-        FE_DFL_ENV.exception_realtraps = SoftFloat::float_exception_realtraps;
+        sFE_DFL_ENV.tininess = SoftFloat::float_detect_tininess;
+        sFE_DFL_ENV.rounding_mode = SoftFloat::float_rounding_mode;
+        sFE_DFL_ENV.exception_realtraps = SoftFloat::float_exception_realtraps;
     }
     // Now get the current env in the given argument
     envp->tininess = SoftFloat::float_detect_tininess;
@@ -488,13 +488,13 @@ inline int fegetenv(fenv_t *envp) {
 }
 
 /// Sets FP env from the given structure
-inline int fesetenv(const fenv_t *envp) {
+inline int fesetenv(const sfenv_t *envp) {
     // check that default env exists, otherwise save it now
-    if (FE_DFL_ENV.tininess==42) {
+    if (sFE_DFL_ENV.tininess==42) {
         // First use: save default environment now
-        FE_DFL_ENV.tininess = SoftFloat::float_detect_tininess;
-        FE_DFL_ENV.rounding_mode = SoftFloat::float_rounding_mode;
-        FE_DFL_ENV.exception_realtraps = SoftFloat::float_exception_realtraps;
+        sFE_DFL_ENV.tininess = SoftFloat::float_detect_tininess;
+        sFE_DFL_ENV.rounding_mode = SoftFloat::float_rounding_mode;
+        sFE_DFL_ENV.exception_realtraps = SoftFloat::float_exception_realtraps;
     }
     // Now get the current env in the given argument
     SoftFloat::float_detect_tininess = envp->tininess;
@@ -504,9 +504,9 @@ inline int fesetenv(const fenv_t *envp) {
 }
 
 /// get env and clear exceptions
-inline int feholdexcept(fenv_t *envp) {
+inline int feholdexcept(sfenv_t *envp) {
     fegetenv(envp);
-    feclearexcept(FE_ALL_EXCEPT);
+    sfeclearexcept(FE_ALL_EXCEPT);
     return 0;
 }
 
diff --git a/rts/lib/streflop/SMath.cpp b/rts/lib/streflop/SMath.cpp
index 749d613..86ede4d 100644
--- a/rts/lib/streflop/SMath.cpp
+++ b/rts/lib/streflop/SMath.cpp
@@ -32,11 +32,11 @@ namespace streflop {
 
     // Default environment. Initalized to 0, and really set on first access
 #if defined(STREFLOP_X87)
-    fenv_t FE_DFL_ENV = 0;
+    sfenv_t sFE_DFL_ENV = 0;
 #elif defined(STREFLOP_SSE)
-    fenv_t FE_DFL_ENV = {0,0};
+    sfenv_t sFE_DFL_ENV = {0,0};
 #elif defined(STREFLOP_SOFT)
-    fenv_t FE_DFL_ENV = {42,0,0};
+    sfenv_t sFE_DFL_ENV = {42,0,0};
 #else
 #error STREFLOP: Invalid combination or unknown FPU type.
 #endif
diff --git a/rts/lib/streflop/libm/flt-32/e_exp2f.cpp b/rts/lib/streflop/libm/flt-32/e_exp2f.cpp
index 8432cdc..016ce39 100644
--- a/rts/lib/streflop/libm/flt-32/e_exp2f.cpp
+++ b/rts/lib/streflop/libm/flt-32/e_exp2f.cpp
@@ -56,7 +56,7 @@ __ieee754_exp2f (Simple x)
       int tval, unsafe;
       Simple rx, x22, result;
       union ieee754_float ex2_u, scale_u;
-      fenv_t oldenv;
+      sfenv_t oldenv;
 
       feholdexcept (&oldenv);
 #ifdef FE_TONEAREST
diff --git a/rts/lib/streflop/libm/flt-32/s_nearbyintf.cpp b/rts/lib/streflop/libm/flt-32/s_nearbyintf.cpp
index 426ecab..1030545 100644
--- a/rts/lib/streflop/libm/flt-32/s_nearbyintf.cpp
+++ b/rts/lib/streflop/libm/flt-32/s_nearbyintf.cpp
@@ -38,7 +38,7 @@ TWO23[2]={
 	Simple x;
 #endif
 {
-	fenv_t env;
+	sfenv_t env;
 	int32_t i0,j0,sx;
 	u_int32_t i,i1;
 	Simple w,t;
